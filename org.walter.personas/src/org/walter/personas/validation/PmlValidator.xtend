/*
 * generated by Xtext
 */
package org.walter.personas.validation

import org.eclipse.xtext.validation.Check
import org.walter.personas.pml.Persona
import org.walter.personas.pml.DefaultProperty
import static extension org.walter.personas.util.U.getKeywordValueFor
import org.walter.personas.pml.PmlPackage
import org.walter.personas.pml.CustomProperty
import org.walter.personas.pml.CustomAttribute
import org.eclipse.xtext.EcoreUtil2
import org.walter.personas.pml.Template
import org.walter.personas.pml.PmlRoot
import org.eclipse.emf.common.util.EList
import org.walter.personas.pml.FullName
import org.walter.personas.pml.Age
import org.walter.personas.pml.Sex
import org.walter.personas.pml.Description
import com.google.common.base.Strings

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class PmlValidator extends AbstractPmlValidator {

	public static val INVALID_ATTRIBUTE_TYPE = 'invalidAttributeType'
	public static val INVALID_ATTRIBUTE = 'invalidAttribute'
	public static val INVALID_ENUM_VALUE = 'invalidEnumValue'
	public static val INVALID_PROPERTY = 'invalidProperty'
	public static val UNRESOLVED_TEMPLATE = 'unresolvedTemplate'
	public static val MISSING_REQUIRED_DEFAULT = 'missingRequiredDefault'
	public static val MISSING_REQUIRED_CUSTOM = 'missingRequiredCustom'

	@Check
	def checkIfRequiredAttributeIsMissing(Persona persona) {
		val templateI = persona.template
		if (templateI != null) {
			templateI.defaults.forEach [ ^default |
				if (!persona.rgproperty.filter(DefaultProperty).exists[prop|
					^default.equals(prop.eClass.keywordValueFor)]) {
					error('The attribute ' + ^default + ' is missing for the use of template ' + templateI.name, persona,
						PmlPackage.Literals.PERSONA__TEMPLATE, MISSING_REQUIRED_DEFAULT,
						^default)
				}
			]
			
			templateI.customs.filter[!Strings.isNullOrEmpty(required)].forEach [ custom |
				if (!persona.rgproperty.filter(CustomProperty).exists[ prop |
					val ca = prop.customAttributeRef.eContainer as CustomAttribute
					EcoreUtil2.equals(ca, custom)]) {
					error('The attribute ' + custom.caName.name + ' is missing for the use of template ' + templateI.name, persona,
						PmlPackage.Literals.PERSONA__TEMPLATE, MISSING_REQUIRED_CUSTOM,
						custom.caName.name, custom.createValueExpression)
				}
			]

		}

	}

	var numberTemplateCounter = 0
	def createValueExpression(CustomAttribute attribute) {
		if (!attribute.rgenumValue.empty) {
			return "(${" + attribute.rgenumValue?.get(0).name + ":Enum('value')})"
		}
		switch (attribute.attributeType.getName()) {
			case "NUMBER": return (this.numberTemplateCounter = this.numberTemplateCounter + 1).toString
			case "TEXT": return attribute.caName.name.replaceAll("\\s+", "")
		}
	}

	@Check
	def checkIfAttributeTypeIsEnum(CustomProperty cp) {
		val ca = cp.customAttributeRef.eContainer as CustomAttribute
		if (ca?.rgenumValue.empty && cp.enumValue != null)
			error(
				'The value ' + cp.enumValue.name + ' is not available for the property ' +
					cp.customAttributeRef?.name, PmlPackage.Literals.CUSTOM_PROPERTY__ENUM_VALUE,
				INVALID_ATTRIBUTE_TYPE)
	}

	@Check
	def checkIfEnumValueIsValid(CustomProperty cp) {
		val ca = cp.customAttributeRef.eContainer as CustomAttribute
		if (!ca.rgenumValue.empty && !ca.rgenumValue.contains(cp.enumValue))
			error('This value is not available for the property ' + cp.customAttributeRef?.name,
				PmlPackage.Literals.CUSTOM_PROPERTY__ENUM_VALUE, INVALID_ENUM_VALUE)
	}

	@Check
	def checkPersonaAttributes(Persona persona) {
		if (persona.template == null) {
			persona.rgproperty.forEach [ it, i |
				switch (it) {
					CustomProperty: {
						if (customAttributeRef.eContainer.eContainer instanceof Template) {
							val template = customAttributeRef.eContainer.eContainer as Template
							error(
								'The property ' + customAttributeRef?.name + ' is defined in the template ' +
									template.name + '. In order to use it, explicitly refer to this template.',
								PmlPackage.Literals.PERSONA__RGPROPERTY, i, INVALID_ATTRIBUTE)
						}
					}
				}
			]
		}
	}

	@Check
	def checkTemplateCompliance(Persona persona) {
		if (persona.template != null) {
			val template = persona.template

			//val allowedDefaults = template.defaults
			val allowedCustoms = template.customs

			persona.rgproperty.forEach [ it, i |
				switch it {
					//DefaultProperty case !it.isValidDefault(allowedDefaults): {
					//  error('The used template ' + template.name + ' does not provide this property',
					//	CharacterScriptPackage.Literals.CHARACTER__PROPERTIES, i, INVALID_PROPERTY)
					//}
					CustomProperty case !it.isValidCustom(allowedCustoms): {
						error('The used template ' + template.name + ' does not provide this property',
							PmlPackage.Literals.PERSONA__RGPROPERTY, i, INVALID_PROPERTY)
					}
				}
			]
		}
	}

	@Check
	def checkForDoubledAttributes(Persona persona) {
		persona.rgproperty.forEach [
			switch it {
				DefaultProperty: {
					val outer = it
					val doubled = persona.rgproperty.filter(DefaultProperty)
						.filter[!EcoreUtil2.equals(it, outer)]
						.findFirst[it.eClass == outer.eClass]

					if (doubled != null) {
						val index = persona.rgproperty.indexOf(doubled)
						error('You cannot use a property twice',
							PmlPackage.Literals.PERSONA__RGPROPERTY, index, INVALID_PROPERTY)
					}
				}
				CustomProperty: {
					val outer = it
					val doubled = persona.rgproperty.filter(CustomProperty).filter[!EcoreUtil2.equals(it, outer)].findFirst[
						EcoreUtil2.equals(it.customAttributeRef, outer.customAttributeRef)]

					if (doubled != null) {
						val index = persona.rgproperty.indexOf(doubled)
						error('You cannot use a property twice',
							PmlPackage.Literals.PERSONA__RGPROPERTY, index, INVALID_PROPERTY)
					}
				}
			}
		]
	}

	@Check
	def checkImports(Persona persona) {
		if (persona.template != null) {
			val template = persona.template
			val root = (persona.eContainer as PmlRoot)
			val imports = root.rgimport

			val matchedImport = imports.findFirst[it.importedNamespace.equals(template.name)]

			if (matchedImport == null) {
				val templates = root.rgtemplate
				val matchedTemplate = templates.findFirst[it.name.equals(template.name)]

				if (matchedTemplate == null) {
					error('Missing import for template ' + template.name,
						PmlPackage.Literals.PERSONA__TEMPLATE, UNRESOLVED_TEMPLATE, template.name)
				}
			}
		}

	}

	def boolean isValidCustom(CustomProperty property, EList<CustomAttribute> list) {
		if (list.contains(property.customAttributeRef.eContainer)) {
			return true
		}
		false
	}

	def dispatch boolean isValidDefault(FullName property, EList<String> list) {
		if (list.contains('full name')) {
			return true
		}
		false
	}

	def dispatch boolean isValidDefault(Age property, EList<String> list) {
		if (list.contains('age')) {
			return true
		}
		false
	}

	def dispatch boolean isValidDefault(Sex property, EList<String> list) {
		if (list.contains('sex')) {
			return true
		}
		false
	}

	def dispatch boolean isValidDefault(Description property, EList<String> list) {
		if (list.contains('description')) {
			return true
		}
		false
	}

	def dispatch boolean isValidDefault(DefaultProperty property, EList<String> list) {
		throw new RuntimeException("Missing evaluation for this default property: " + property.class)
	}
	
}
